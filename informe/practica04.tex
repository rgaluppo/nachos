\chapter{Resolución de la Práctica N\grad4: Memoria virtual y TLB}
\section{Implementar TLB} \label{update_TLB}
Capturamos las excepciones \texttt{PageFaultException} y \texttt{ReadOnlyException}.\\
Cuando ocurre la primera, se obtiene la dirección de memoria que la originó leyendo el valor del registro \texttt{R39}. Luego se invoca a \texttt{AddrSpace::UpdateTLB} para que cree una nueva entrada en la tabla para dicho valor. Notemos que al retornar no se realiza un aumento en el \texttt{PC}. Por lo tanto, se ejecutara nuevamente la sentencia que origino la excepción.
\begin{lstlisting}[style=C]
if (which == SyscallException) {
	...
} else {
	DEBUG('e', "Is not a SyscallException\n");
    const char *exception = "";
    switch(which) {
    	...
        case PageFaultException:
        {
            int failVirtAddr = machine -> ReadRegister(BadVAddrReg);

            DEBUG('v',"Antes de actualizar la TLB: failVAddr=%d\n",
                    failVirtAddr);
            currentThread->space->UpdateTLB(failVirtAddr / PageSize);
            return;
        }
        case ReadOnlyException: 
        exception = "ReadOnlyException";
        // Solamente notificamos que ocurrio.
        printf("An exception was triggered: which=%s  type=%d\n",
                    exception, type);
        return;    
        ...
        
    	default:
            printf("Unexpected user mode exception.");
            ASSERT(false);
    }
    printf("Unexpected exception:\t which=%s  type=%d\n",
                    exception, type);
    ASSERT(false);
}
\end{lstlisting}
Como mencionamos anteriormente, se modificó la clase \texttt{AddrSpace}
\begin{lstlisting}[style=C]
void UpdateTLB(int position);   // update TLB table;
TranslationEntry* GetEntryByVAddr(int i);  // Getter for an entry 
   // in a translation table, corresponding to the virtual address i.
\end{lstlisting}
Se utiliza para cuando la página a utilizar no se encuentra en el \textbf{TLB}. Se encarga de buscarla en la memoria y guardarla en la \textbf{TLB}.
\section{Análisis de TLB cambiando la cantidad de entradas}
\subsection*{Modificaciones}
Para ver como influye el tamaño de la \textbf{TLB} respecto a la cantidad de paginas que fallan, se agregaron dos indicadores a las estadísticas de \textbf{NachOS}. Ellos se encuentran en \texttt{stats.h}.
\begin{lstlisting}[style=C]
int numPageFaults;  // number of virtual memory page faults
int numPagesFound;  // number of virtual memory page founds
\end{lstlisting}
El primero se incrementa cuando ocurre un fallo de paginación. Esto ocurre cuando se captura la excepción \texttt{PageFaultException}. En cambio, el segundo se incrementa cuando se encuentra la pagina. Ocurre al final del constructor \texttt{Translate::Translate}.\\
Para modificar el tamaño de la TLB, se modifica la variable \texttt{TLBSize}, declarada en \texttt{system.h}.
\subsection*{Resultados}
Se realizaron distintas pruebas variando la cantidad de entradas de la tabla. Los valores de prueba fueron 4, 16, 32, 64 y 128. Además, la página que sale es elegida al azar.\\
En \ref{tab:practica04:statics} se muestra los porcentajes de aciertos y fallas de la \textbf{TLB}, para los programas \texttt{matmult.c} y \texttt{sort.c}.\\ 
\begin{table}
	\center
	\begin{tabular}{|c|c|c|c|c|}
	    \hline
		\multirow{3}{*}{TLB size}   &    \multicolumn{4}{c|}{Programa}           \\
		\cline{2-5}
            &            \multicolumn{2}{c|}{\texttt{mathmult}}    &    \multicolumn{2}{c|}{\texttt{sort}} \\
        \cline{2-5}
            &    faults    &    hits       &    faults    &    hits    \\
		\hline
		4   &    7,60\%    &    92,39\%    &    4,36\%    &    95,64\% \\
       16   &    0,569\%   &    99,43\%    &    0,042\%   &    99,958\%   \\
       32   &    0,013\%   &    99,986\%   &    0,035\%   &    99,996\%    \\               
       64   &    0,006\%   &    99,993\%   &    0,0001\%  &    99,999\%    \\               
      128   &    0,006\%   &    99,993\%   &    0,0001\%  &    99,999\%    \\    \hline             
	\end{tabular}
    \caption{Estadísticas para los programas \texttt{mathmult} y \texttt{sort}, variando el tamaño de la TLB.}
	\label{tab:practica04:statics}
\end{table}
Para ésta forma de seleccionar la página  que sale de la \textbf{TLB}, encontramos una cota máxima de rendimiento en una tabla con 64 entradas. Notamos que una tabla con mas entradas, se sigue teniendo el mismo rendimiento.
\newpage
\section{Implementar carga por demanda}
Cuando se inicia un programa, no va a tener ninguna de sus páginas en memoria. Ellas, se cargarán cuando el sistema solicite acceder a alguna de ellas.\\
Para implementar esto, cuando se crea el espacio de direcciones de un thread se le asigna \texttt{-{}1} a la dirección física de cada una de sus páginas y a su vez se setea el bit de \texttt{valid} en \texttt{false}. Con esto último se indica que la página no está en memoria. Por lo tanto, las páginas se irán cargando en memoria conforme se reciban las \texttt{PageFaultException}.\\
Se agregaron los siguientes métodos a la clase \texttt{AddrSpace}:
\begin{lstlisting}[style=C]
public:
    ...
    void LoadPage(TranslationEntry *page);//Load a page into memory.
private:
    OpenFile *executable_file; // Save executeble for load later.
    NoffHeader noff_hdr; // Save header for load later
    
    // Class constructor with DEMAND_LOADING flag
    void costructorForDemandLoading(OpenFile *executable,
                int prg_argc, char** prg_argv, int pid);
\end{lstlisting}
Se modificó el método \texttt{AddrSpace::UpdateTLB} para que se verifique el estado de la página. Si ya tiene asignada una dirección física, se continúa con la actualización del \textbf{TLB} como se explicó en \nameref{update_TLB}. En caso contrario, se llama al método \texttt{AddrSpace::LoadPage}, el cual le asigna a la página una posición en el mapa de bits y la carga en memoria. Finalmente, continua la ejecución de \texttt{AddrSpace::UpdateTLB} para actualizar el \textbf{TLB}.
\section{Implementar la política de paginación FIFO e implementar SWAP}
\subsection*{Desarrollo de SWAP}
Con el objetivo de proveer la ilusión de una memoria mucho más grande que la física, cuando se crea el espacio de direcciones para un programa, se creará un archivo que servirá de \textbf{SWAP}.\\
Además, necesitamos saber qué páginas se encuentran \textit{swappeadas}. Para manejar esto, se crea un arreglo \texttt{swapMemory} de booleanos, donde el \texttt{i-ésimo} elemento indica si la página \texttt{i} está o no \textit{swappeada}.\newpage
Se agregaron los siguiente miembros a la clase \texttt{AddrSpace}:
\begin{lstlisting}[style=C]
private:
    ...
    OpenFile *swapFile;     // File for swapping.
    char swapFileName[8];   // Name of swapping file.
    int* swapMemory;    // Boolean list that indicates if a page is on SWAP.
\end{lstlisting}
Finalmente, se creó una estructura para llevar un control de las direcciones físicas ocupadas y con qué direcciones virtuales y procesos están vinculadas. Esta estructura está implementada en la clase \texttt{CoreMap}, y es una modificación de la clase \texttt{BitMap}:
\begin{lstlisting}[style=C]
class CoreMap {
  public:
    CoreMap(int nitems); // Initialize a CoreMap, with "nitems" bits
                        // initially, all bits are cleared.

    ~CoreMap();    // De-allocate CoreMap
    
    void Mark(int which, int pid, int vir);    // Set the "nth" bit
    void Clear(int which);    // Clear the "nth" bit

    int Find(int virtualPage); //Effect, set the bit. If no bits are
        // clear, find a page candite to leave the memory and
        // put it into swap. Then, return his place into the memory.
    
    int NumClear();    // Return the number of clear bits
    void Print();    // Print contents of CoreMap
    
  private:
    BitMap *memoryMap; // Indicates wich frames are free.
    int numbit;    // Indicates the amount of elements of memoryMap.

    int* pids;    // List of pids. The pid[i] is the threadId
                 // corresponding to page i.
    
    int* virAdds;    // List of virtual address that was loaded
                    // into the memory.


    int fifoAlgorithm(); // Return the virtual address of the page 
                        // candidated to leave memory using
                        // FIFO algorithm.

    int secondChanceAlgorithm(); // Return the virtual address of
                        // the page candidated to leave memory
                        // using 'second chance' algorithm.
};
\end{lstlisting}
\subsection*{Política de paginación FIFO}
\section{Mejorar la política de paginación}