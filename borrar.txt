20a21
> #include "stats.h"
21a23,28
> //#include "noff.h"
> 
> 
> 
> //#define Code(i) (&(machine->mainMemory[Fis(noffH.code.virtualAddr+i)+(noffH.code.virtualAddr + i % PageSize)]))
> //#define Fis(i) pageTable[(i)/PageSize].physicalPage*PageSize
45,47c52,55
< // AddrSpace:: LoadSegment
< //      Load a segment into the Nachos's main memory to can run the
< //      excecutable user program
---
> // AddrSpace::AddrSpace
> // 	Create an address space to run a user program.
> //	Load the program from a file "executable", and set everything
> //	up so that we can start executing user instructions.
49,82c57,63
< //  seg A segment (code or data).
< //  readingSize Size of the segment.
< //  exec Executable file owner of the segment.
< //  initOffset This is where begins the reading.
< //  fileOffset Offset of executable file.
< //----------------------------------------------------------------------
< unsigned int
< AddrSpace:: LoadSegment (Segment seg, unsigned int readingSize, OpenFile* exec, int initOffset,
<                          unsigned int fileOffset)
< {
<     unsigned int offset = 0;
<     int file_off,
<         phys_addr,
<         virt_addr;
<     if(readingSize > 0) {
<         virt_addr = divRoundUp(seg.virtualAddr, PageSize);
<         offset = initOffset;
< 
<         while(offset <= readingSize) {
<             file_off = fileOffset + offset;
<             phys_addr = pageTable[virt_addr].physicalPage * PageSize;
< 
<             exec->ReadAt(&(machine->mainMemory[phys_addr]), PageSize, file_off);
< 
<             virt_addr++;
<             offset = offset + PageSize;
<         }
<     }
<     return offset;
< }
< 
< //----------------------------------------------------------------------
< // AddrSpace::costructorForUserProg
< //  Class constructor without flags
---
> //	Assumes that the object code file is in NOFF format.
> //
> //	First, set up the translation from program memory to physical 
> //	memory.  For now, this is really simple (1:1), since we are
> //	only uniprogramming, and we have a single unsegmented page table
> //
> //	"executable" is the file containing the object code to load into memory
84,134d64
< void
< AddrSpace::costructorForUserProg(OpenFile *executable, int prg_argc, char** prg_argv, int pid)
< {
<     NoffHeader noffH;
<     unsigned int i,
<             size,
<             offset;
<     int firstFreePhySpace = -1;
< 
<     argc = prg_argc;
<     argv = prg_argv;
< 
<     executable->ReadAt((char *)&noffH, sizeof(noffH), 0);
<     if ((noffH.noffMagic != NOFFMAGIC) &&
<         (WordToHost(noffH.noffMagic) == NOFFMAGIC))
<         SwapHeader(&noffH);
<     ASSERT(noffH.noffMagic == NOFFMAGIC);
< 
< // how big is address space?
<     size = noffH.code.size + noffH.initData.size + noffH.uninitData.size
<             + UserStackSize;	// we need to increase the size
<                         // to leave room for the stack
<     numPages = divRoundUp(size, PageSize);
<     size = numPages * PageSize;
< 
< // check we're not trying to run something too big -.-
<     ASSERT(numPages <=(unsigned) NumPhysPages);
<     ASSERT(numPages <= (unsigned) memoryMap->NumClear());
< 
<     DEBUG('a', "Initializing address space, num pages %d, size %d\n", numPages, size);
< // first, set up the translation
<     pageTable = new TranslationEntry[numPages];
< 
<     for (i = 0; i < numPages; i++) {
<         pageTable[i].virtualPage = i;
< 
<         firstFreePhySpace = memoryMap->Find();
<         ASSERT(firstFreePhySpace != -1);	//Always found space in physical memory.
< 
<         pageTable[i].physicalPage = firstFreePhySpace;
<         pageTable[i].valid = true;
<         pageTable[i].use = false;
<         pageTable[i].dirty = false;
<         pageTable[i].readOnly = false;  // if the code segment was entirely on
<                                         // a separate page, we could set its
<                                         // pages to be read-only
< 
<         // zero out the every page address space, to zero the unitialized data segment
<         // and the stack segment
<         bzero(&(machine->mainMemory[firstFreePhySpace*PageSize]), PageSize);
<     }
136,147c66
< // then, copy in the code and data segments into memory
<     offset = LoadSegment(noffH.code, noffH.code.size, executable, 0, noffH.code.inFileAddr);
<     LoadSegment(noffH.initData, noffH.code.size + noffH.initData.size, executable, offset, noffH.code.inFileAddr);
< }
< 
< #ifdef DEMAND_LOADING
< //----------------------------------------------------------------------
< // AddrSpace::costructorForDemandLoading
< //  Class constructor with DEMAND_LOADING flag
< //----------------------------------------------------------------------
< void
< AddrSpace::costructorForDemandLoading(OpenFile *executable, int prg_argc, char** prg_argv, int pid)
---
> AddrSpace::AddrSpace(OpenFile *executable, int th_argc, char** th_argv, int pid)
149,194c68,69
<     NoffHeader noffH;
<     unsigned int i,
<             size;
<     int firstFreePhySpace = -1;
< 
<     argc = prg_argc;
<     argv = prg_argv;
< 
<     executable->ReadAt((char *)&noffH, sizeof(noffH), 0);
<     if ((noffH.noffMagic != NOFFMAGIC) &&
<         (WordToHost(noffH.noffMagic) == NOFFMAGIC))
<         SwapHeader(&noffH);
<     ASSERT(noffH.noffMagic == NOFFMAGIC);
< 
< // how big is address space?
<     size = noffH.code.size + noffH.initData.size + noffH.uninitData.size
<             + UserStackSize;	// we need to increase the size
<                         // to leave room for the stack
<     numPages = divRoundUp(size, PageSize);
<     size = numPages * PageSize;
<     swapMemory = new int [numPages];
< 
<     DEBUG('a', "Initializing address space, num pages %d, size %d\n", numPages, size);
< // first, set up the translation
<     pageTable = new TranslationEntry[numPages];
< 
<     for (i = 0; i < numPages; i++) {
<         pageTable[i].virtualPage = i;
< 
< #ifdef USE_TLB
<         pageTable[i].physicalPage = firstFreePhySpace;
<         pageTable[i].valid = false;
<         swapMemory[i] = false;
<         DEBUG('W', "Pagina por Demanda\n");
< #else
<         firstFreePhySpace = memoryMap->Find();
<         ASSERT(firstFreePhySpace != -1);	//Always found space in physical memory.
<         pageTable[i].physicalPage = firstFreePhySpace;
<         pageTable[i].valid = true;
< #endif
< 
<         pageTable[i].use = false;
<         pageTable[i].dirty = false;
<         pageTable[i].readOnly = false;  // if the code segment was entirely on
<                                         // a separate page, we could set its
<                                         // pages to be read-only
---
> 	argc = th_argc;
> 	argv = th_argv;
196,199d70
<     }
< 
<     noff_hdr = noffH;
<     executable_file = executable;
201,219c72,73
< }
< #endif
< 
< #ifdef VM_SWAP
< //----------------------------------------------------------------------
< // AddrSpace::costructorForSwap
< //  Class constructor with VM_SWAP flag
< //----------------------------------------------------------------------
< void
< AddrSpace::costructorForSwap(OpenFile *executable, int prg_argc, char** prg_argv, int pid)
< {
<  NoffHeader noffH;
<     unsigned int i,
<             size;
< #ifndef DEMAND_LOADING
<     unsigned int offset;
< #endif
<     argc = prg_argc;
<     argv = prg_argv;
---
>     NoffHeader noffH;
>     unsigned int i, size;
220a75
> 	
222,224c77,79
<     if ((noffH.noffMagic != NOFFMAGIC) &&
<         (WordToHost(noffH.noffMagic) == NOFFMAGIC))
<         SwapHeader(&noffH);
---
>     if ((noffH.noffMagic != NOFFMAGIC) && 
> 		(WordToHost(noffH.noffMagic) == NOFFMAGIC))
>     	SwapHeader(&noffH);
227,230c82,85
< // how big is address space?
<     size = noffH.code.size + noffH.initData.size + noffH.uninitData.size
<             + UserStackSize;	// we need to increase the size
<                         // to leave room for the stack
---
> 	// how big is address space?
>     size = noffH.code.size + noffH.initData.size + noffH.uninitData.size 
> 			+ UserStackSize;	// we need to increase the size
> 						// to leave room for the stack
233,235d87
< #if defined(VM_SWAP) || defined(DEMAND_LOADING)
<     swapMemory = new int [numPages];
< #endif
237,241c89
< #ifndef VM
< // check we're not trying to run something too big -.-
<     ASSERT(numPages <=(unsigned) NumPhysPages);
<     ASSERT(numPages <= (unsigned) memoryMap->NumClear());
< #endif
---
>     swapTable = new int [numPages];
243,245c91,108
<     DEBUG('a', "Initializing address space, num pages %d, size %d\n", numPages, size);
< // first, set up the translation
<     pageTable = new TranslationEntry[numPages];
---
> 	#ifndef VM
> 			ASSERT(numPages <=(unsigned) NumPhysPages);		// check we're not trying
> 			ASSERT(numPages <= (unsigned) myBitmap->NumClear());					// to run anything too big --
> 								// at least until we have
> 								// virtual memory
> 	#endif
> 
>   //  DEBUG('a', "Initializing address space, num pages %d, size %d\n",	numPages, size);
> // first, set up the translation 
> 	  #ifdef DEMAND_LOADING
> 		
> 		noff = noffH;
> 	  	exec = executable;
> DEBUG('A',"pid=%d,\t threadName=%s\n", pid, proccessTable[pid]->getName());
> DEBUG('A',"noff.code.virtualAddr=%d,\t noff.initData.virtualAddr=%d\n", noffH.code.virtualAddr, noffH.initData.virtualAddr);
> 	  #endif  
> 		
> 	pageTable = new TranslationEntry[numPages];
247d109
<     int firstFreePhySpace = -1;
249,300c111,112
<         pageTable[i].virtualPage = i;
< #ifdef USE_TLB
<     #ifdef VM_SWAP
<         #ifndef DEMAND_LOADING
<         pageTable[i].physicalPage = coreMap->Find(pageTable[i].virtualPage);
<         fifo->Append(pageTable[i].physicalPage);
<         swapMemory[i] = false;
<         #endif
<     #endif // FIN VM_SWAP
<     #ifdef DEMAND_LOADING
<         pageTable[i].physicalPage = firstFreePhySpace;
<         pageTable[i].valid = false;
<         swapMemory[i] = false;
<         DEBUG('W', "Pagina por Demanda\n");
<     #endif// FIN DEMAND_LOADING
<     #ifndef VM_SWAP
<         #ifndef DEMAND_LOADING
<         firstFreePhySpace = memoryMap->Find();
<         ASSERT(firstFreePhySpace != -1);	//Always found space in physical memory.
<         pageTable[i].physicalPage = firstFreePhySpace;
<         #endif
<     #endif //FIN VM_SWAP
< #else
<         firstFreePhySpace = memoryMap->Find();
<         ASSERT(firstFreePhySpace != -1);	//Always found space in physical memory.
<         pageTable[i].physicalPage = firstFreePhySpace;
<         pageTable[i].valid = true;
< #endif
< 
<         pageTable[i].use = false;
<         pageTable[i].dirty = false;
<         pageTable[i].readOnly = false;  // if the code segment was entirely on
<                                         // a separate page, we could set its
<                                         // pages to be read-only
<     }
< 
< #ifndef DEMAND_LOADING
< // then, copy in the code and data segments into memory
<     offset = LoadSegment(noffH.code, noffH.code.size, executable, 0, noffH.code.inFileAddr);
<     LoadSegment(noffH.initData, noffH.code.size + noffH.initData.size, executable, offset, noffH.code.inFileAddr);
< #endif
< 
< #ifdef DEMAND_LOADING
<     noff_hdr = noffH;
<     executable_file = executable;
< #endif
< #ifdef VM_SWAP
<     sprintf(swapFileName, "swap.%d", pid);
<     ASSERT(fileSystem->Create(swapFileName, size));
<     swapFile = fileSystem->Open(swapFileName);
<     DEBUG('G', "CREO SWAP %s \n",swapFileName);
<  #endif
---
> 		pageTable[i].virtualPage = i;
> 		#ifdef USE_TLB
301a114,187
> 				// for now, virtual page # = phys page #
> 			//pageTable[i].valid = true; // Para memoria virtual modificar valid = false
> 			#ifdef VM_SWAP
> 				#ifndef DEMAND_LOADING
> 				pageTable[i].physicalPage = coreMap->Find(pageTable[i]);
> 				fifo->Append(pageTable[i].physicalPage);
>                 swapTable[i] = false;
> 			    #endif	
> 			#endif //idef VM_SWAP				  
> 			#ifdef DEMAND_LOADING
> 					// for now, virtual page # = phys page #
> 				pageTable[i].physicalPage = -1;
> 				pageTable[i].valid = false; // Para memoria virtual modificar valid = false
>                 swapTable[i] = false;
>                 DEBUG('G', "Pagina por Demanda\n");
> 			#endif// ifdef DEMAND_LOADING
> 			#ifndef VM_SWAP
> 				#ifndef DEMAND_LOADING
> 			 		 pageTable[i].physicalPage = myBitmap->Find();
> 				#endif
> 			#endif
> 		
> 		#else
> 		//pageTable[i].virtualPage = i;	
> 		pageTable[i].valid = true; 
> 		pageTable[i].physicalPage = myBitmap->Find();//i;
> 		#endif
> 		pageTable[i].use = false;
> 		pageTable[i].dirty = false;
> 		pageTable[i].readOnly = false;  // if the code segment was entirely on 
> 					// a separate page, we could set its 
> 					// pages to be read-only
>     }
> 
> 	
> 	#ifndef DEMAND_LOADING
> 	//Limpiamos la memoria
> 	for(i = 0; i < numPages; i++)
> 	{
> 		bzero( &(machine->mainMemory[pageTable[i].physicalPage*PageSize]), PageSize);
> 	}
> 
> 	unsigned int j;
> 	
> 	if (noffH.code.size > 0){
> 		j = divRoundUp(noffH.code.virtualAddr, PageSize);
> 		for (i = 0; i <= (unsigned)noffH.code.size ; i=i+PageSize ){
> 			executable->ReadAt(&(machine->mainMemory[pageTable[j].physicalPage * PageSize]),PageSize, noffH.code.inFileAddr+i); 
> 				j++;
> 		}
> 	}
> 	else 
> 		i=0;
> 
> 	if (noffH.initData.size > 0){
> 		
> 		j = divRoundUp(noffH.initData.virtualAddr, PageSize);
> 		for ( ; i < (unsigned)(noffH.code.size + noffH.initData.size) ;i=i+PageSize ){
> 			executable->ReadAt(&(machine->mainMemory[pageTable[j].physicalPage * PageSize]),PageSize, noffH.code.inFileAddr+i);
> 			j++;
> 		}
> 	}
> 
> 	#endif
> 	// si usamos Paginacion
>    #ifdef VM_SWAP
> 	sprintf(swapName,"swap.%d",pid);
>     if(!fileSystem->Create(swapName,size))
> 		DEBUG('G', "ERROR CREAR SWAP");
> 	else
> 		swapMem = fileSystem->Open(swapName);
> 	DEBUG('G', "CREO SWAP %s \n",swapName);
> 	#endif
> 	//swapMem->WriteAt("FUnciona???",11, 0);*/
303,317d188
< #endif
< //----------------------------------------------------------------------
< // AddrSpace::AddrSpace
< // 	Create an address space to run a user program.
< //	Load the program from a file "executable", and set everything
< //	up so that we can start executing user instructions.
< //
< //	Assumes that the object code file is in NOFF format.
< //
< //	First, set up the translation from program memory to physical 
< //	memory.  For now, this is really simple (1:1), since we are
< //	only uniprogramming, and we have a single unsegmented page table
< //
< //	"executable" is the file containing the object code to load into memory
< //----------------------------------------------------------------------
319,320d189
< AddrSpace::AddrSpace(OpenFile *executable, int prg_argc, char** prg_argv, int pid)
< {
322,332d190
< #if defined(VM_SWAP) || defined(DEMAND_LOADING)
<     #ifdef VM_SWAP
<     costructorForSwap(executable, prg_argc, prg_argv, pid);
<     #else
<     costructorForDemandLoading(executable, prg_argc, prg_argv, pid);
<     #endif
< #else
<     costructorForUserProg(executable, prg_argc, prg_argv, pid);
< #endif
< 
< }
337a196
> 
340,423c199,204
<     int physicalAddr;
< #ifdef VM_SWAP
<     int fifoadd, fifohead;
< #endif
< 
<     for (unsigned int i=0; i< numPages; i++) {
<         physicalAddr = pageTable[i].physicalPage;
<         if (physicalAddr != -1) {
< #ifdef VM_SWAP
<             coreMap->Clear(physicalAddr);
<             fifohead = fifo->Remove();
<             if(fifohead != physicalAddr) {
<                 fifo->Append(fifohead);
<                 fifoadd = fifo->Remove();
< 
<                 while(fifoadd != fifohead) {
<                     if(fifoadd != physicalAddr) {
<                         fifo->Append(fifoadd);
<                     }
<                     fifoadd = fifo->Remove();
<                 }
<                 fifo->Prepend(fifoadd);
<             }
<         }
<     }
<     ASSERT(fileSystem->Remove(swapFileName));
< #else
<             memoryMap->Clear(pageTable[i].physicalPage);
<         }
<     }
< #endif
< 
<     delete pageTable;
< }
< 
< //----------------------------------------------------------------------
< // AddrSpace::InitArguments
< // 	Set the arguments values for the user program.
< //----------------------------------------------------------------------
< void
< AddrSpace::InitArguments() {
<     DEBUG('e', "Iniciando argumentos...\n");
< 
<     DEBUG('e', "argc=%d\t", argc);
<     for(int w=0; w<argc; w++)
<         DEBUG('e', "argv[%d]=%s\n", w, argv[w]);
< 
<     int length;
<     int SP;
<     int Argv_addr[argc];
<     int Arg_addr;
<     bool writeDone;
< 
<     if(argc > 0) {
<         for(int i = 0; i<argc; i++) {
<             length = strlen(argv[i]) + 1;
<             SP = machine->ReadRegister(StackReg);
< 
<             Arg_addr = SP-length;
< 
<             for(int j = 0; j < length; j++) {
<                 writeDone = machine->WriteMem(Arg_addr+j, 1, argv[i][j]);
<                 ASSERT(writeDone);
<             }
< 
<             machine->WriteRegister(StackReg, Arg_addr);
<             Argv_addr[i] = Arg_addr;
<         }
< 
<         SP = machine->ReadRegister(StackReg);
<         machine->WriteRegister(StackReg, SP-(SP % 4));
< 
<         for(int i = argc; i >= 0 ; i--) {
<             SP = machine -> ReadRegister(StackReg);
<             writeDone = machine->WriteMem(SP-4, 4, Argv_addr[i]);
<             ASSERT(writeDone);
<             machine->WriteRegister(StackReg, SP-4);
<         }
< 
<         SP = machine->ReadRegister(StackReg);
<         machine->WriteRegister(StackReg, SP-16);
<         machine->WriteRegister(4, argc);
<         machine->WriteRegister(5, SP);
<     }
---
> 	
> 	RestoreState();
> 	CleanMap();
> 	delete pageTable;
> 	
> 	
455,457d235
<    // allocated the stack; but subtract off a bit, to make sure we don't
<    // accidentally reference off the end!
<     machine->WriteRegister(StackReg, numPages * PageSize - 16);
468,477c246,256
< void
< AddrSpace::SaveState()
< { 
< #ifdef USE_TLB
<     for(int i=0; i < TLBSize; i++){
<         if(machine->tlb[i].valid){
<             pageTable[machine->tlb[i].virtualPage] = machine->tlb[i];
<         }
<     }
< #endif
---
> 
> void AddrSpace::SaveState() 
> {	
> 	#ifdef USE_TLB
> 	int i;
> 	for(i=0; i < TLBSize; i++){
> 		if(machine->tlb[i].valid){
> 			pageTable[machine->tlb[i].virtualPage] =machine->tlb[i];
> 		}
> 	}	
>     #endif
487,493c266,269
< void
< AddrSpace::RestoreState()
< {
< #ifdef USE_TLB
<     for(int i=0 ; i < TLBSize ; i++)
<         machine->tlb[i].valid = false;
< #else
---
> 
> void AddrSpace::RestoreState() 
> {	
> 	#ifndef USE_TLB
494a271
> 	
496,497c273,281
<     DEBUG('s', "Restore state for %s: register PC = %d\n", currentThread->getName(), machine->ReadRegister(34));
< #endif
---
> 	
>    	#else
> 	int i;
> 	for(i=0 ; i < TLBSize ; i++){
> 		
> 		machine->tlb[i].valid = false;
> 		
> 	}
>     #endif
501,511c285,449
< //----------------------------------------------------------------------
< // AddrSpace::GetEntryByVAddr
< //  Obtains the page corresponding to a given virtual address.
< //
< // i A virtual address.
< // return The correspinding page.
< //----------------------------------------------------------------------
< TranslationEntry*
< AddrSpace ::GetEntryByVAddr(int i)
< {
<     return &(pageTable[i]);
---
> // CleanMap limpia la bitmap de un proceso de usuario que terminó
> void AddrSpace::CleanMap(){
> 	int i;
> 	int phys, fifoadd, fifohead, aux;
> 	#ifdef VM_SWAP
> 		for (i=0; i< (int)numPages; i++){
> 			phys = 	pageTable[i].physicalPage;			
> 			if ( phys != -1)
> 			{
> 				coreMap->Clear(phys);
> 				fifohead = fifo->Remove();
> 				
> 				if(fifohead != phys)
> 					{
> 						fifo->Append(fifohead);
> 						fifoadd = fifo->Remove();
> 					
> 					while(fifoadd != fifohead)			
> 					{
> 				 		if(fifoadd != phys)
> 						{
> 						fifo->Append(fifoadd);
> 						}
> 						fifoadd = fifo->Remove();
> 			   		}
> 					fifo->Prepend(fifoadd);					
> 					}
> 			}
> 		}
> 	ASSERT(fileSystem->Remove(swapName));
> 	#else
> 		for (i=0; i< (int)numPages; i++){
> 			if (pageTable[i].physicalPage != -1){
> 				myBitmap->Clear(pageTable[i].physicalPage);
> 			}
> 		}
> 	#endif
> 
> }
> void AddrSpace::InitArguments(){
> 	
> 	int length;
> 	int SP;
> 	int Argv_addr[argc];
> 	int Arg_addr;
> 
> 	if(argc > 0)
> 	{
> 		for(int i = 0; i<argc; i++)
> 		{
> 			length = strlen(argv[i]) + 1;
> 			SP = machine->ReadRegister(StackReg);
> 			
> 			Arg_addr = SP - length;
> 			
> 			for(int j = 0; j < length; j++)
> 			 if(!machine->WriteMem(Arg_addr+j,1,argv[i][j]))
> 			 	ASSERT(machine->WriteMem(Arg_addr+j,1,argv[i][j]));
> 			 
> 			
> 			machine->WriteRegister(StackReg,Arg_addr);
> 			Argv_addr[i] = Arg_addr;
> 	
> 		}
> 		SP = machine->ReadRegister(StackReg);
> 		machine->WriteRegister(StackReg, SP - (SP % 4));
> 		
> 		for(int i = argc; i >= 0 ; i--)
> 		{
> 			SP = machine -> ReadRegister(StackReg);
> 			if(!machine->WriteMem(SP-4,4,Argv_addr[i]))
> 				ASSERT(machine->WriteMem(SP-4,4,Argv_addr[i]));
> 			machine->WriteRegister(StackReg,SP-4);
> 	  	}
> 	  	
> 	  	SP = machine->ReadRegister(StackReg);
> 	  	machine->WriteRegister(StackReg, SP - 16);
> 	  	machine->WriteRegister(4,argc);
> 	  	machine->WriteRegister(5, SP);
> 	  		
> 	}	
> 
> }
> 
> // 
> // ActualizaTLB
> 
> void AddrSpace::ManagePage(	TranslationEntry *page, int p)
> {
> 
>         DEBUG('G', "Pagina pos = %d .... phys = %d ...Valid = %o ... swap = %o \n", p, page->physicalPage, page->valid, swapTable[p]);
> 	
> 
>     if (page->physicalPage == -1 && !swapTable[p]){ //no esta cargado en memoria
> 		 
> 		#ifdef DEMAND_LOADING
> 		
> 		CargarPagina(page);
> 		#endif
> 		
> 		#ifdef VM_SWAP
>             fifo->Append(page->physicalPage);
> 
> 		DEBUG('G', " Despues de fifo Append-----%d \n",p);
> 		#endif
> 
> 	}
> 	else 
>        if(swapTable[p])
> 		{	
> 			#ifdef VM_SWAP
> 				
> 				
> 				int bitIndex = coreMap->Find(page->virtualPage);
> 				page->physicalPage = bitIndex;
> 
> 				SwapToMem(page);
> 				fifo->Append(page->physicalPage);
> 
> 				DEBUG('G', "Swap \n");
> 
> 			#else
> 				ASSERT(false);
> 			#endif	
> 		}
> }	
> void AddrSpace::ActualizarTlb(int p)
> {
> 	int k = ValidPage(); // posicion validad en el TLB
> 	
> 	
> 	TranslationEntry *page = InvPageTable(p);
> 	#if defined(VM_SWAP) || defined(DEMAND_LOADING)
> 		ManagePage(page,p);
> 	#endif
> 	page->valid = true;
> 	machine->tlb[k].virtualPage = page->virtualPage;
> 	machine->tlb[k].physicalPage = page->physicalPage;
> 	machine->tlb[k].dirty = page->dirty;
> 	machine->tlb[k].use = page->use;			// esta en el tlb
> 	machine->tlb[k].valid = page->valid;
> 	machine->tlb[k].readOnly = page->readOnly;
> 	DEBUG('G', "Valor del virtualPage = %d \n",page->virtualPage);
> 
> 	
> }
> 
> //
> //
> int AddrSpace::ValidPage()
> {
> 	int k;
> 	
> 	for(k = 0; k < TLBSize && (machine->tlb[k].valid); k++);
> 	
> 	/*
> 		si k = TLBSIZE; --> Otra forma de elegir;
> 		
> 	*/
> 	
> 	if(k == TLBSize)
> 		k = Random() % TLBSize;
> 	
> 	return k;
> 	
514,522c452
< //----------------------------------------------------------------------
< //  AddrSpace::UpdateTLB
< // When an entry does not appear in the TLB, a PageFaultException is
< // triggered, allowing this page to be added in the TLB.
< //
< // position Is the virtual address that failed
< //----------------------------------------------------------------------
< void
< AddrSpace::UpdateTLB(int position)
---
> int AddrSpace::UpdateTLB(int p)
524,551c454
<     int freeSlot = -1;
<     TranslationEntry* page = GetEntryByVAddr(position);
< 
< #if defined(DEMAND_LOADING) || defined(VM_SWAP)
<     OnDemandLoad(page, position);
< #endif
< 
<     //Busco un lugar disponible en la TLB.
<     for (int i = 0; i < TLBSize; i++){
<         if(machine->tlb[i].valid == false){
<             freeSlot = i; // Encontre un espacio libre.
<             break;
<         }
<     }
<     if(freeSlot == -1){
<         // No hay espacio libre en la TLB, elijo uno aleatoreamente.
<         freeSlot = Random() % TLBSize;
<     }
<     DEBUG('V',"Found space in TLB: freeSlot=%d\n", freeSlot);
< 
<     // Pongo la pagina en el TLB.
<     page->valid = true;
<     machine->tlb[freeSlot].virtualPage = page->virtualPage;
<     machine->tlb[freeSlot].physicalPage = page->physicalPage;
<     machine->tlb[freeSlot].dirty = page->dirty;
<     machine->tlb[freeSlot].use = page->use;			// esta en el tlb
<     machine->tlb[freeSlot].valid = page->valid;
<     machine->tlb[freeSlot].readOnly = page->readOnly;
---
>     int k;
553c456,459
<     DEBUG('V',"Finish updateTLB\n");
---
>     for(k = 0; k < TLBSize; k++)
>         if (machine->tlb[k].physicalPage == p)
>                 machine->tlb[k].valid = false;
>     return 0;
556,568c462
< 
< #ifdef VM
< //----------------------------------------------------------------------
< // AddrSpace::OnDemandLoad
< //  The pages of code or data of the executable will be loaded when it is
< // required to access that page. That is, when the PageFaultException
< // exception occurs.
< //
< // page A page that will be loaded.
< // errorAdd A virtual address that failed
< //----------------------------------------------------------------------
< void
< AddrSpace::OnDemandLoad(TranslationEntry *page, int errorAddr)
---
> void AddrSpace :: NoSwap(int pos)
570,594c464,468
<     DEBUG('W', "Pagina pos = %d .... phys = %d ...Valid = %o ...\n swap = %d", errorAddr,
<           page->physicalPage, page->valid, swapMemory[errorAddr]);
< 
<     if(page->physicalPage == -1 && !swapMemory[errorAddr]) { // no esta cargado en memoria
< 
< #ifdef DEMAND_LOADING
<         LoadPage(page);
< #endif
< #ifdef VM_SWAP
<         fifo->Append(page->physicalPage);
<         DEBUG('G', " Despues de fifo Append-----%d \n", errorAddr);
< #endif
<     } else if(swapMemory[errorAddr]) {
< #ifdef VM_SWAP
<         int bitIndex = coreMap->Find(page->virtualPage);
<         page->physicalPage = bitIndex;
< 
<         SwapToMem(page);
<         fifo->Append(page->physicalPage);
< 
<         DEBUG('G', "Swap \n");
< #else
<         ASSERT(false);
< #endif
<     }
---
> 		
> 	pageTable[pos].physicalPage = -1;
> 	pageTable[pos].valid = false;
> 	
> 	
596d469
< #endif
598,613d470
< #ifdef DEMAND_LOADING
< //----------------------------------------------------------------------
< // AddrSpace::LoadPage
< //
< // page A page that will be loaded.
< //----------------------------------------------------------------------
< void
< AddrSpace::LoadPage(TranslationEntry *page)
< {
<     unsigned int virtualAddr,
<             code_start,
<             data_start,
<             file_offset;
< 
<     int freePhysAddr;
<     DEBUG('W',"LoadPage\n");
615,621c472,473
< #ifdef VM_SWAP
<     freePhysAddr = coreMap->Find(page->virtualPage);
< #else
<     freePhysAddr = memoryMap->Find();
< #endif
< 
<     page->physicalPage = freePhysAddr;
---
> TranslationEntry* AddrSpace ::InvPageTable(int i)
> {
623,636c475,476
<     virtualAddr = page->virtualPage * PageSize;
<     code_start = divRoundUp(noff_hdr.code.virtualAddr, PageSize);
<     data_start = divRoundUp(noff_hdr.initData.virtualAddr, PageSize);
<     file_offset = noff_hdr.code.inFileAddr + virtualAddr;
< 
<     DEBUG('W',"physAddr=%d\t virtualAddr=%d\n", freePhysAddr, virtualAddr);
< 
<     if(virtualAddr >= code_start && virtualAddr < data_start) {
<         executable_file->ReadAt(&(machine->mainMemory[page->physicalPage * PageSize]),
<                 PageSize, file_offset);
<     } else {
<         executable_file->ReadAt(&(machine->mainMemory[page->physicalPage * PageSize]),
<                 PageSize, file_offset);
<     }
---
> 	return &(pageTable[i]);
> 	
638,647d477
< #endif
< 
< #ifdef VM_SWAP
< //----------------------------------------------------------------------
< // AddrSpace::SetUse
< //  Mark as used a page.
< //
< // i A virtual address.
< // b A state who indicates is the page is used or not.
< //----------------------------------------------------------------------
651c481
<     pageTable[i].use = b;
---
> 	pageTable[i].use = b;
654,660d483
< //----------------------------------------------------------------------
< // AddrSpace::IsValid
< //  Getter for bit valid of a page.
< //
< // p A virtual address.
< // return The value of bit valid.
< //----------------------------------------------------------------------
662c485
< AddrSpace :: IsValid(int p)
---
> AddrSpace :: Valid(int p)
664c487
<     return pageTable[p].valid;
---
> 	return pageTable[p].valid;
667,673d489
< //----------------------------------------------------------------------
< // AddrSpace::IsUsed
< //  Getter for bit used of a page.
< //
< // p A virtual address.
< // return The value of bit used.
< //----------------------------------------------------------------------
675c491
< AddrSpace :: IsUsed(int p)
---
> AddrSpace :: Used(int p)
677c493
<     return pageTable[p].use;
---
> 	return pageTable[p].use;
680,686d495
< //----------------------------------------------------------------------
< // AddrSpace::IsDirty
< //  Getter for bit dirty of a page.
< //
< // p A virtual address.
< // return The value of bit dirty.
< //----------------------------------------------------------------------
688c497
< AddrSpace :: IsDirty(int p)
---
> AddrSpace :: Dirty(int p)
690c499
<     return pageTable[p].dirty;
---
> 	return pageTable[p].dirty;
693,699c502,503
< //----------------------------------------------------------------------
< // AddrSpace::NoSwap
< //  Obtains the page corresponding to a given virtual address.
< //
< // i A virtual address.
< // return The correspinding page.
< //----------------------------------------------------------------------
---
> #ifdef DEMAND_LOADING
> 
701c505
< AddrSpace :: NoSwap(int pos)
---
> AddrSpace :: CargarPagina(TranslationEntry *page)
703,704c507,547
<     pageTable[pos].physicalPage = -1;
<     pageTable[pos].valid = false;
---
> 	unsigned int i,code_j, data_j;
>     int bitIndex;
> 	
> 	#ifndef USE_TLB
> 		ASSERT(numPages <=(unsigned) NumPhysPages);// check we're not trying
> 	#endif
> 	#ifdef VM_SWAP
> 		 //bitIndex = coreMap->Find(page);
> 		 bitIndex = coreMap->Find(page->virtualPage);
> 	#else
> 		 bitIndex = myBitmap->Find();
> 	#endif	
> 
> 	if (bitIndex == -1){
> 		ASSERT(false);
> 		
> 	} 
> 	else {
> 		page->physicalPage = bitIndex;
> 	}
> 
> 	int p = page->virtualPage;	
> 
> 	code_j = divRoundUp(noff.code.virtualAddr, PageSize);
> 
> 	i = p*PageSize; //+ code_j;
> 
> 	data_j = divRoundUp(noff.initData.virtualAddr, PageSize);
> DEBUG('A',"noff.code.virtualAddr=%d,\t noff.initData.virtualAddr=%d\n", noff.code.virtualAddr, noff.initData.virtualAddr);
> 		DEBUG('A',"i=%d,\t code_j=%d,\t data_j=%d\n", i, code_j, data_j);
> 	if(i >= code_j && i < data_j)
> 	{
> 		DEBUG('A',"SOY CODIGO\n");
>         exec->ReadAt(&(machine->mainMemory[page->physicalPage * PageSize]),PageSize, noff.code.inFileAddr+i);
> 	}	
> 	else
> 	{	
> 		DEBUG('A',"SOY DATO\n");
>         exec->ReadAt(&(machine->mainMemory[page->physicalPage * PageSize]),PageSize, noff.code.inFileAddr+i);
> 	}
> 			
706,709c549,551
< 
< //----------------------------------------------------------------------
< // AddrSpace::UpdateTLB2
< //  Obtains the page corresponding to a given virtual address.
---
> #endif
> //FUNCIONES DE SWAP
> #ifdef VM_SWAP
711,727d552
< // i A virtual address.
< // return The correspinding page.
< //----------------------------------------------------------------------
< int
< AddrSpace::UpdateTLB2(int p)
< {
<     int k;
< 
<     for(k = 0; k < TLBSize; k++)
<         if (machine->tlb[k].physicalPage == p)
<                 machine->tlb[k].valid = false;
<     return 0;
< }
< 
< //----------------------------------------------------------------------
< // AddrSpace::MemToSwap
< //  Obtains the page corresponding to a given virtual address.
729,731d553
< // i A virtual address.
< // return The correspinding page.
< //----------------------------------------------------------------------
733c555
< AddrSpace :: MemToSwap(int vpn)
---
> AddrSpace :: MemToSwap(int vpn) //AddrSpace :: MemToSwap(TranslationEntry *page)
737,739c559,561
<     TranslationEntry *page = GetEntryByVAddr(vpn);
<     int p = page->virtualPage;
<     int i = p*PageSize;
---
> 	TranslationEntry *page = InvPageTable(vpn);	
> 	int p = page->virtualPage; 
> 	int i = p*PageSize;
741,742c563,564
<     DEBUG('G', "1Pagina pos = %d .... phys = %d  .... vir = %d ...Valid = %o ... swap = %o \n", p, page->physicalPage, page->virtualPage, page->valid, swapMemory[vpn]);
<     swapFile->WriteAt(&(machine->mainMemory[page->physicalPage * PageSize]),PageSize, i);
---
>     DEBUG('G', "1Pagina pos = %d .... phys = %d  .... vir = %d ...Valid = %o ... swap = %o \n", p, page->physicalPage, page->virtualPage, page->valid, swapTable[vpn]);
>     swapMem->WriteAt(&(machine->mainMemory[page->physicalPage * PageSize]),PageSize, i);
746c568
<     swapMemory[vpn] = true;
---
>     swapTable[vpn] = true;
748,752c570,573
<     page->valid = false;
<     page->dirty = false;
< 
<     DEBUG('G', "2Pagina pos = %d .... phys = %d  .... vir = %d ...Valid = %o ... swap = %o \n", p, page->physicalPage, page->virtualPage, page->valid, swapMemory[vpn]);
< 
---
> 	page->valid = false;
> 	page->dirty = false;
> 	
>     DEBUG('G', "2Pagina pos = %d .... phys = %d  .... vir = %d ...Valid = %o ... swap = %o \n", p, page->physicalPage, page->virtualPage, page->valid, swapTable[vpn]);
754c575,576
<     //bzero( &(machine->mainMemory[page->physicalPage*PageSize]), PageSize);
---
> 	
> 	//bzero( &(machine->mainMemory[page->physicalPage*PageSize]), PageSize);
756c578
<     //modificar el tlb de esa pagina
---
> 	//modificar el tlb de esa pagina
759,765d580
< //----------------------------------------------------------------------
< // AddrSpace::SwapToMem
< //  Obtains the page corresponding to a given virtual address.
< //
< // i A virtual address.
< // return The correspinding page.
< //----------------------------------------------------------------------
769c584,585
<     int p = page->virtualPage;
---
> 	int p = page->virtualPage;
> 	int i = p*PageSize;
771,773c587,589
<     swapFile->ReadAt(&(machine->mainMemory[page->physicalPage * PageSize]),PageSize, p);
<     swapMemory[p] = false;
<     DEBUG('G', "DENTRO DE VM_SWAP SwapToMem\n");
---
>     swapMem->ReadAt(&(machine->mainMemory[page->physicalPage * PageSize]),PageSize, i);
>     swapTable[p] = false;
> 	DEBUG('G', "DENTRO DE VM_SWAP SwapToMem\n");
