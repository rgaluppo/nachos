\chapter{Resolución de la Práctica N\grad4}
\section{}
\textbf{\textit{exception.cc}}
Capturamos las excepciones \textit{PageFaultException} y \textit{ReadOnlyException}:\\
\begin{lstlisting}[style=C]
if (which == SyscallException) {
	...
} else {
	DEBUG('e', "Is not a SyscallException\n");
    const char *exception = "";
    switch(which){
    	...
    	
		case PageFaultException:
		{
	    	int failVirtAddr = machine -> ReadRegister(BadVAddrReg);

	        DEBUG('v',"\n Antes de actualizar la TLB: failVAddr=%d \n", failVirtAddr);
	        stats->numPageFaults++;
			currentThread->space->UpdateTLB(failVirtAddr / PageSize);
	        return;
		}
	    case ReadOnlyException: 
	    	exception = "ReadOnlyException";
    	    break;
    	    
    	...
    	
    	default:
                printf("Unexpected user mode exception.");
                ASSERT(false);
        }
    printf("Unexpected user mode exception:\t which=%s  type=%d\n", exception, type);
    ASSERT(false);
}
\end{lstlisting}
\textbf{\textit{addrspace.h}}
Se agrega el método \textit{void UpdateTLB(int position)}, el cual dada un índice, obtiene la página correspondiente de memoria.\\
Dicho método se utiliza para cuando la página a utilizar no se encuentra en el TLB. Se encarga de buscarla en la memoria y guardarla en el TLB\\
\textbf{\textit{addrspace.cc}}
Se implementa el método \textit{void UpdateTLB(int position)}:\\
\begin{lstlisting}[style=C]
void AddrSpace::UpdateTLB(int position)
{
    int freeSlot = -1;
    TranslationEntry page = pageTable[position];

    //Busco un lugar disponible en la TLB.
    for (int i = 0; i < TLBSize; i++){
        if(machine->tlb[i].valid == false){
            freeSlot = i;
            DEBUG('v',"Found space in TLB: freeSlot=%d\n", freeSlot);
            break;
        }
    }
    if(freeSlot == -1){
        // No hay espacio libre en la TLB, elijo uno aleatoreamente.
        freeSlot = Random() % TLBSize;
    }
	
    page.valid = true;
    machine->tlb[freeSlot] = page;
    DEBUG('v',"Finish updateTLB\n");
}
\end{lstlisting}
\section{}
La tabla \ref{tab:practica04:statics} nos muestra las estadísticas sobre la cantidad de aciertos y fallas al utilizar el buffer de traducción adelantada, para los programas \textit{Sort} y \textit{Matmult}. Además, se realizaron distintas pruebas variando el tamaño del buffer. Agregamos a la estadística los casos de 128 y 256 entradas.\\
\begin{table}[!ht]
	\center
	\begin{tabular}{|c|c|c|}
		\hline
		\rowcolor{gray!50}
		Programa					&	TLB size			& Valores			\\	\hline
		\multirow{10}{*}{Sort}		&	\multirow{2}{*}{4}	& faults: 1.014.833	\\
									&						& hits: 22.235.837	\\
									&	\multirow{2}{*}{32}	& faults: 765		\\
									&						& hits: 21.818.027	\\
									&	\multirow{2}{*}{64}	& faults: 39		\\
									&						& hits: 21.817.385	\\
									&	\multirow{2}{*}{128}& faults: 39		\\
									&						& hits: 21.817.385	\\
									&	\multirow{2}{*}{256}& faults: 39		\\
									&						& hits: 21.817.385	\\ 	\hline
		\multirow{10}{*}{Matmult}	&	\multirow{2}{*}{4}	& faults: 62.644	\\
									&						& hits:	761.344		\\
									&	\multirow{2}{*}{32}	& faults: 99		\\
									&						& hits: 726.245		\\
									&	\multirow{2}{*}{64}	& faults: 46		\\
									&						& hits: 726.197		\\
									&	\multirow{2}{*}{128}& faults: 46		\\
									&						& hits: 726.197		\\
									&	\multirow{2}{*}{256}& faults: 46		\\
									&						& hits: 726.197		\\ 	\hline

	\end{tabular}
	\caption{Estadísticas para los programas Sort y MatMult, variando el tamaño de la TLB.}
	\label{tab:practica04:statics}
\end{table}
Para ésta forma de seleccionar cuál página sale de la TLB (elegimos una al azar), encontramos una cota máxima de rendimiento.\\
Notamos que a partir de una tabla de 64 entradas, obtenemos la mayor cantidad de aciertos y la menor cantidad de fallos.\\